//layers.js
'use strict';

// https://webgl2fundamentals.org/webgl/lessons/webgl-render-to-texture.html
// https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html
// https://webgl2fundamentals.org/webgl/lessons/webgl-2d-matrix-stack.html
// https://twgljs.org/docs/index.html

//Instead of an array of edit items, we are going to end up with an array of layers
//order of array will create layer order

//layer is created by a primitive, or shader function
//the texture and the vert and the frag can be generated by prim
//uniforms are generated from prim properties

//one difference between "Edit" frags and "Stub" frags is that
//edit frags need to get mPt and dPt automatically, maybe other uniforms
//need to be able to convert between edit and baked layer

//layers also should be able to be created by combining multiple prims

//dimensional constraints could be at the point level
//point.x = 7
//point a = point b
//point = (scene.points.['id']) => { scene.points.['id'] }
//point a = 5units from point b
//point = (scene.points.['id'], dist) => { (scene.points.['id'] - point) * dist }
import {gl, state, resolution, mPt, dPt} from './sdfui.js';
import * as FS from './frag/frags.js';
import * as BAKE from './bakeLayer.js';
import * as PRIM from './primitives.js';

// to be treated as a drawObject by twgl we need these properties
// { programInfo: programInfo,
//   bufferInfo: plane,
//   uniforms: this.uniforms,}
// can't have property named "type"
export class Layer {
  constructor(prim, vert, frag, uniforms){
    if(typeof prim != 'object' || typeof vert != 'string' || typeof frag != 'string' || typeof uniforms != 'object'){
      console.log('layer constructor is invalid, check inputs');
      return;
    }
    //not allowed to have prop named type
    this.primType = prim.type.slice();
    if(prim.id){
      this.prim = prim.id.slice();  
    }
    
    this.vert = vert.slice();
    this.frag = frag.slice();
    this.uniforms = {...uniforms};

    // data texture
    this.editTex = new PRIM.PolyPoint(16);
    this.uniforms.u_eTex = this.editTex;

    //layer properties
    this.properties = {...state.ui.properties};
    //bbox is set on bake
    this.bbox = null;
    this.needsUpdate = false;
    this.id = (+new Date).toString(36).slice(-8);
    let idCol = chroma.random().gl();
    this.idCol = twgl.v3.create(idCol[0], idCol[1], idCol[2]);

    //creates a full screen layer
    //matrix transformation, transformation can be baked into layer
    this.matrix = twgl.m4.ortho(0, gl.canvas.clientWidth, gl.canvas.clientHeight, 0, -1, 1);
    // translate our quad to dstX, dstY
    this.matrix = twgl.m4.translate(this.matrix, twgl.v3.create(0, 0, 0));
    // scale our 1 unit quad - from 1 unit to texWidth, texHeight units
    // will also want to translate/rotate plane at some point
    this.matrix = twgl.m4.scale(this.matrix, twgl.v3.create(gl.canvas.width, gl.canvas.height, 1));

    this.uniforms.u_matrix = this.matrix;
    this.uniforms.u_idCol = this.idCol;

    //create program
    this.programInfo = twgl.createProgramInfo(gl, [vert, frag]);

    //create plane
    let positions = new Float32Array([0,0, 0,1, 1,0, 1,0, 0,1, 1,1,]);

    let texcoords = new Float32Array([0,0, 0,1, 1,0, 1,0, 0,1, 1,1,]);

    var arrays = {
      position: {numComponents: 2, data: positions},
      texcoord: {numComponents: 2, data:texcoords}
    }

    // this is the plane
    this.bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);

    gl.useProgram(this.programInfo.program);

    twgl.setBuffersAndAttributes(gl, this.programInfo, this.bufferInfo);
  }
}

export function setBoundingBox(layer){
  layer.bbox = new PRIM.bbox(layer.editTex.pts);
  console.log(layer.bbox);
  updateMatrices(layer);
}

export function updateMatrices(layer){
  // ------
  // texture clipping per:
  // https://webgl2fundamentals.org/webgl/lessons/webgl-2d-drawimage.html
  let minX = ((layer.bbox.min.x * (64. / dPt.z) + dPt.x) * resolution.x) * (resolution.y/resolution.x);
  let minY = ((layer.bbox.min.y * (64. / dPt.z) + dPt.y) * resolution.y);
  
  let width = ((layer.bbox.width * (64. / dPt.z)) * resolution.x) * (resolution.y/resolution.x);
  let height = (layer.bbox.height * (64. / dPt.z)) * resolution.y;
  
  //matrix transformation, transformation can be baked into layer
  layer.matrix = twgl.m4.ortho(0, gl.canvas.clientWidth, gl.canvas.clientHeight, 0, -1, 1);

  layer.matrix = twgl.m4.translate(layer.matrix, twgl.v3.create(minX, minY, 0));
  // scale our 1 unit quad - from 1 unit to texWidth, texHeight units
  layer.matrix = twgl.m4.scale(layer.matrix, twgl.v3.create(width, height, 1));

  layer.uniforms.u_matrix = layer.matrix;

  let texMatrix = twgl.m4.translation(twgl.v3.create(minX / resolution.x, minY / resolution.y, 0));
  texMatrix = twgl.m4.scale(texMatrix, twgl.v3.create(width / resolution.x, height / resolution.y, 1));
  // layer.uniforms.u_resolution = twgl.v3.create(width, height, 0);
  layer.uniforms.u_textureMatrix = texMatrix;
}

//when baking object properties should remain parameterized
//that way changing color, weight of line doesn't require recompilation of shader
//actually changing pt positions won't need shader recompilation either
export function bakeLayer(layer){
  //set bounding box
  setBoundingBox(layer);
  //compile shader
  //let shader = BAKE.bake
  let fs = BAKE.bake(layer);
  layer.frag = fs;
  // console.log(fs);
  layer.programInfo = twgl.createProgramInfo(gl, [layer.vert, fs]);
  gl.useProgram(layer.programInfo.program);
  twgl.setUniforms(layer.programInfo, layer.uniforms);
  console.log(layer);
  //transform bounding box
  //profit
}

//this just creates a new 
export function bakePrim(prim){
  let layer = createLayerFromPrim(prim);
  bakeLayer(layer);
}

//this is great - can make a raw layer, or create from prim
//need to figure out best way to confirm if something has been updated
//maybe best way would be to have an update counter
//every time a prim has been updated check to see if counters match
export function createLayerFromPrim(prim){
  //get program stub for prim type
  let fs = getFragStub(prim.type);
  
  let vs = FS.simpleVert.slice();
  //get the points
  let pts = [];
  for (let p of state.scene.pts){
    if(prim.pts.includes(p.id)){
      pts.push(p);
    }
  }
  // which of these methods is better?
  // scenePts = [...state.scene.pts];
  // scenePts.filter(p => prim.pts.includes(p.id));

  //
  //create PolyPoint
  let editTex = new PRIM.PolyPoint(16);
  //add pts to PolyPt
  for(let p of pts){
    editTex.addPt(p);
  }
  //get the uniforms from prim
  let uniforms = {
    u_resolution: twgl.v3.create(gl.canvas.width, gl.canvas.height, 0),
    u_panOffset: twgl.v3.create(dPt.x, dPt.y, 0),
    u_mPt: twgl.v3.create(mPt.x, mPt.y, 0),
    u_dPt: twgl.v3.create(dPt.x, dPt.y, 0),
    u_eTex: editTex,
    u_weight: prim.properties.weight,
    u_stroke: twgl.v3.create(0.0, 0.435, 0.3137), //need to convert to prim.properties.stroke
  };
  //return new Layer
  let layer = new Layer(prim, vs, fs, uniforms);
  setBoundingBox(layer);
  return layer;
}

export function getFragStub(type){
  switch(type){
    case'polyline':
      return FS.pLineStub.slice();
    default:
      return FS.pLineStub.slice();
  }
}


//future idea for increased performance, UI elements
//export function renderToTexture(layer, size)